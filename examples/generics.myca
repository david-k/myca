/*struct M:?mut Slice'T
{
	ptr: [^]M T,
	length: usize,
}*/


// &own is essentially equivalent to an r-value reference in C++
/*proc Array.add(self &mut, val: &own T)
{
	self.buf[self.length] = val;
	self.length += 1;
}*/


proc main() -> i32
{
	let mut val = 3;
	let arr = Array'i32(
		.buf = &mut val as [^]mut i32,
		.length = 1,
		.capacity = 1,
	);

	let arrb: Arr = arr;
	let p: [^]i32 = arrb.buf;

	// []&mut T == ?mut Slice'T

	//let a: []mut i32;
	//let b: []i32 = a;

	let brr: Array'isize = mk_array'isize();

	return foo();
}

typealias Arr = Array'(i32);

struct Array'T
{
	buf: [^]mut T,
	length: usize,
	capacity: usize,
}


proc mk_array'T() -> Array'T
{
	return Array'T(null, 0, 0);
}

/*proc max(a: usize, b: usize) -> usize
{
	if a < b {
		return b;
	}

	return a;
}

proc push'T (arr: ^mut Array'T, val: T)
{
	if arr^.size + 1 > arr^.capacity {
		let new_cap = max(arr^.capacity * 2, 1);
		grow_capacity'T(arr, new_cap);
	}

	arr^.buf[arr^.size] = val;
	arr^.size = arr^.size + 1;
}

proc grow_capacity'T (arr: ^mut Array'T, target_cap: usize)
{
	// assert(arr^.size <= target_cap);

	let new_buf = malloc(target_cap * size_of(T)) as [^]mut T;
	let i: usize = 0;
	while i < arr^.size {
		new_buf[i] = arr^.buf[i];
		i = i + 1;
	}

	arr^.buf = new_buf;
	arr^.capacity = target_cap;
}*/







struct Option'T
{
	case Some{value: T},
	case None{},
}


proc bar()
{
	let opt = IntOpt.Some(3);
}
typealias IntOpt = Option'i32;


proc foo() -> i32
{
	let opt = Option'(Vec2'i32).Some(Vec2'i32(8, 9));

	let bv = Vec2'bool(true, false);
	let b: bool = bv.y;

	let vec: Vec2i = opt.value;

	let player = Player'i32(
		.pos = vec
	);

	let v = player.pos;

	if b {
		return v.y + player.health;
	} else {
		return v.x + player.health;
	}
}

struct Vec2'S
{
	x: S,
	y: S,
}

struct Player'T
{
	pos: Vec2'T,
	health: i32 = 100,
}

typealias Vec2i = Vec2'i32;
