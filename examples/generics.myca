/*struct M:?mut Slice'T
{
	ptr: [^]M T,
	length: usize,
}*/


// &own is essentially equivalent to an r-value reference in C++
/*proc Array.add(self &mut, val: &own T)
{
	self.ptr[self.length] = val;
	self.length += 1;
}*/


proc main() -> i32
{
	let mut val = 3;
	let arr = Array'i32(
		.ptr = &mut val as [^]mut i32,
		.length = 1,
		.capacity = 1,
	);

	let arrb: Arr = arr;
	let p: [^]i32 = arrb.ptr;

	// []&mut T == ?mut Slice'T

	//let a: []mut i32;
	//let b: []i32 = a;

	return foo();
}

typealias Arr = Array'(i32);

struct Array'T
{
	ptr: [^]mut T,
	length: usize,
	capacity: usize,
}






struct Option'T
{
	case Some{value: T},
	case None{},
}


proc bar()
{
	let opt = IntOpt.Some(3);
}
typealias IntOpt = Option'i32;


proc foo() -> i32
{
	let opt = Option'(Vec2'i32).Some(Vec2'i32(8, 9));

	let bv = Vec2'bool(true, false);
	let b: bool = bv.y;

	let vec: Vec2i = opt.value;

	let player = Player'i32(
		.pos = vec
	);

	let v = player.pos;

	if b {
		return v.y + player.health;
	} else {
		return v.x + player.health;
	}
}

struct Vec2'S
{
	x: S,
	y: S,
}

struct Player'T
{
	pos: Vec2'T,
	health: i32 = 100,
}

typealias Vec2i = Vec2'i32;
