// Lib C
//==============================================================================
struct c_void { _: Never }
typealias c_char = i8;

extern proc malloc(size: usize) -> ^mut c_void;
extern proc free(ptr: ^mut c_void);
extern proc puts(str: [^]c_char) -> i32;


// Main
//==============================================================================
proc main() -> i32
{
	let mut arr = Array'i32();
	add(&mut arr, 3);
	add(&mut arr, 99);

	puts(c"Hello?");

	return id(foo()) + arr.buf[0] + (length(&arr) as i32); // 113
}


// Array
//==============================================================================
struct Array'T
{
	buf: [^]mut T = null,
	length: usize = 0,
	capacity: usize = 0,
}


proc length'T (arr: ^Array'T) -> usize
{
	return arr^.length;
}

proc add'T (arr: ^mut Array'T, val: T)
{
	if arr^.length + (1 as usize) > arr^.capacity {
		let new_cap = max(arr^.capacity * 2, 1);
		grow_capacity(arr, new_cap);
	}

	arr^.buf[arr^.length] := val;
	arr^.length := arr^.length + 1;
}

proc grow_capacity'T (arr: ^mut Array'T, target_cap: usize)
{
	// assert(arr^.length <= target_cap);

	let new_buf = malloc(target_cap * size_of(T)) as [^]mut T;
	let mut i: usize = 0;
	while i < arr^.length {
		new_buf[i] := arr^.buf[i];
		i := i + 1;
	}

	arr^.buf := new_buf;
	arr^.capacity := target_cap;
}


proc max(a: usize, b: usize) -> usize
{
	if a < b {
		return b;
	}

	return a;
}


// &own is essentially equivalent to an r-value reference in C++
/*proc Array.add(self &mut, val: &own T)
{
	self.buf[self.length] = val;
	self.length += 1;
}*/


// Slice
//==============================================================================
/*struct M:?mut Slice'T
{
	ptr: [^]M T,
	length: usize,
}*/


// Misc
//==============================================================================
proc id'T (v: T) -> T
{
	return v;
}


struct Option'T
{
	case Some{value: T},
	case None{},
}


proc bar() -> i32
{
	let opt = IntOpt.Some(3);
	let opt2: Option'(Int).Some = opt;
	let opt3 = Some(55);
	return opt2.value + opt3.value;
}

typealias IntOpt = Option'i32;
typealias Int = i32;
typealias Some'T = Option'(T).Some;


proc foo() -> i32
{
	let opt = Option'(Vec2'i32).Some(Vec2'i32(8, 9));
	let _ = Option.Some(Vec2(8, 9));

	let xxx: Option'bool = Option.Some(false);

	let bv = Vec2(true, false);
	let b: bool = bv.y;

	let vec: Vec2i = opt.value;

	let player = Player'i32(
		.pos = vec
	);

	let v = player.pos;

	if b {
		return v.y + player.health;
	} else {
		return v.x + player.health;
	}
}

struct Vec2'S
{
	x: S,
	y: S,
}

struct Player'T
{
	pos: Vec2'T,
	health: i32 = 100,
}

typealias Vec2i = Vec2'i32;
