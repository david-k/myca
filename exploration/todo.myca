//------------------------------------------------------------------------------
//struct List^T
struct List'T
{
	value: T,
	//next: ?'List^T = None,
	next: ?^List'T = None,
}

proc main() -> i32
{
	let a = List(1);
	let b = List(2, &a);
	let c = List(3, &b);
	let d = List(4, &c);

	let mut cur: Option = &d;
	let mut done = false;
	let mut sum = 0;

	// TODO This is way too verbose
	while not done {
		match cur {
			case Some(let list) {
				sum := sum + list^.value;
				cur := list^.next;
			}
			case None {
				done := true;
			}
		}
	}

	//while cur_opt != None {
	//	sum := sum + cur!'.value;
	//	cur := cur!'.next;
	//}

	return sum;
}


//------------------------------------------------------------------------------
struct Option'T
{
    case implicit Some{value: T},
    case None,
}

typealias Some'T = Option'(T).Some;
typealias None'T = Option'(T).None;

proc unwrap_or'T(opt: ?T, fallback: T) -> T
{
	match opt
	{
		case Some(let value) { return value; }
		case None { return fallback; }
	}
}


//==================================================================================================
// TODO Calling the constructor like `Foo()` causes an assertion failure because T has not been deduced
//==================================================================================================
/*struct Foo'T
{
	x: i32,
}*/
