//------------------------------------------------------------------------------
//struct List^T
struct List'T
{
	value: T,
	//next: ?'List^T = None,
	next: ?^List'T = None,
}

proc main() -> i32
{
	let a = List(1);
	let b = List(2, &a);
	let c = List(3, &b);
	let d = List(4, &c);

	let mut cur: Option = &d;
	let mut done = false;
	let mut sum = 0;

	// TODO This is way too verbose
	while not done {
		match cur {
			case Some(let list) {
				sum := sum + list^.value;
				cur := list^.next;
			}
			case None {
				done := true;
			}
		}
	}

	//while cur is Some(inner: ^List) {
	//	sum := sum + inner.value;
	//	cur := inner.next;
	//}

	return sum;
}


//------------------------------------------------------------------------------
struct Option'T
{
    case implicit Some{value: T},
    case None,
}

typealias Some'T = Option'(T).Some;
typealias None'T = Option'(T).None;

proc unwrap_or'T(opt: ?T, fallback: T) -> T
{
	match opt
	{
		case Some(let value) { return value; }
		case None { return fallback; }
	}
}
