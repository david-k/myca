#pragma once

#include <cassert>
#include <optional>
#include <ostream>
#include <span>
#include <string>
#include <string_view>
#include <variant>
#include <vector>
#include <stdexcept>
#include <memory>

#include "utils.hpp"


using std::optional;
using std::nullopt;
using std::string;
using std::string_view;
using std::variant;
using std::vector;
using std::span;


//==============================================================================
// Tokens
//==============================================================================
enum class Lexeme
{
	IDENTIFIER,
	INT_LITERAL,
	C_STRING_LITERAL,
	TRUE,
	FALSE,

	DOT,
	COMMA,
	COLON,
	SEMICOLON,
	CIRCUMFLEX,
	AMPERSAND,
	QUESTIONMARK,
	BANG,
	SINGLE_QUOTE,
	AT,
	BAR,
	LEFT_PAREN,
	RIGHT_PAREN,
	LEFT_BRACE,
	RIGHT_BRACE,
	LEFT_BRACKET,
	RIGHT_BRACKET,

	THIN_ARROW,

	PLUS,
	MINUS,
	UNARY_MINUS, // Not actually generated by the lexer. Only used for get_operator_info()
	SLASH,
	STAR,
	EQ,
	COLON_EQ,
	DOUBLE_EQ,
	LT,
	LE,
	GT,
	GE,

	NOT,

	LET,
	PROC,
	STRUCT,
	CASE,
	IMPLICIT,

	TYPE_NEVER,
	TYPE_BOOL,
	TYPE_UNIT,
	TYPE_I8,
	TYPE_U8,
	TYPE_I32,
	TYPE_U32,
	TYPE_ISIZE,
	TYPE_USIZE,

	IF,
	ELSE,
	WHILE,
	MATCH,
	RETURN,

	AS,
	MUT,

	TYPEALIAS,
	EXTERN,

	SIZE_OF,
	MAKE,

	END,
};


struct SourceLocation
{
	size_t pos = 0;
	int line = 0;
	int col = 0;
};


struct SourceSpan
{
	SourceLocation begin;
	SourceLocation end;
};

struct Token
{
	Lexeme kind;

	union
	{
		uint64_t int_val{};
		string_view str_val;
	} value{};

	SourceSpan span;
};


string_view str(Lexeme tok);
inline string str(SourceLocation loc) { return std::to_string(loc.line) + ":" + std::to_string(loc.col); }

struct TokenIdx { uint32_t value; };
struct TokenRange { TokenIdx first{}, last{}; };

static constexpr TokenIdx INVALID_TOKEN_IDX = TokenIdx(-1);
static constexpr TokenRange UNKNOWN_TOKEN_RANGE = TokenRange(INVALID_TOKEN_IDX, INVALID_TOKEN_IDX);


//==============================================================================
// AST
//==============================================================================

//--------------------------------------------------------------------
// Types
//--------------------------------------------------------------------
struct Module;
class StructInstance;
class ProcInstance;
class UnionInstance;
struct StructItem;
struct ProcTypeInstance;
struct TypeParameter;
struct Expr;


struct TypeParameterVar
{
	TokenRange range;
	TypeParameter const *def;
};

struct TypeDeductionVar
{
	uint32_t id;

	friend bool operator == (TypeDeductionVar, TypeDeductionVar) = default;
};

using VarType = variant<TypeParameterVar, TypeDeductionVar>;

using Type = variant
<
	struct BuiltinType,
	struct KnownIntType,
	struct PointerType,
	struct ProcType,
	struct StructType,
	struct UnionType,
	VarType,

	// Unresolved types
	struct Path,
	struct ProcTypeUnresolved,
	struct UnionTypeUnresolved,
	struct InlineStructType
>;

enum class BuiltinTypeDef
{
	NEVER,
	UNIT,
	BOOL,
	I8,
	U8,
	I32,
	U32,
	ISIZE,
	USIZE,
};

struct BuiltinType
{
	TokenRange range;
	BuiltinTypeDef builtin;
};

struct KnownIntType
{
	Int128 low;
	Int128 high;
};

struct Path
{
	TokenRange range;
	FixedArray<Type> *type_args = nullptr;
	Path *NULLABLE child = nullptr;
};

enum class IsMutable
{
	YES,
	NO,
};

struct PointerType
{
	enum Kind
	{
		SINGLE,
		MANY,
	};

	TokenRange range;
	Kind kind;
	Type *pointee;
	IsMutable mutability;
};

struct UnionTypeUnresolved
{
	TokenRange range;
	FixedArray<Type> *alternatives = nullptr;
};

struct UnionType
{
	TokenRange range;
	UnionInstance *inst;
};

struct ProcTypeUnresolved
{
	TokenRange range;
	Type *ret;
	FixedArray<Type> *params = nullptr;
};


struct NoDefaultValue {};
struct ExprPending {};
struct DefaultValueExpr : variant<NoDefaultValue, ExprPending, Expr*>
{
	using variant::variant;

	Expr* try_get_expr() const
	{
		return *this | match
		{
			[](Expr *expr) { return expr; },
			[](auto) { return (Expr*)nullptr; },
		};
	}

	NO_DANGLING Expr& get_expr() const
	{
		Expr *expr = try_get_expr();
		assert(expr && "DefaultValueExpr has no expr");
		return *expr;
	}

	explicit operator bool () const
	{
		return *this | match
		{
			[](NoDefaultValue) { return false; },
			[](auto) { return true; },
		};
	}
};

struct ProcType
{
	TokenRange range;
	ProcTypeInstance *inst;

	// This is used for typechecking procedure/constructor calls, but is irrelevant for deciding
	// whether two ProcTypes are equal.
	variant<ProcInstance*, StructInstance*> callable;

	size_t param_count() const;
	Type* param_type_at(size_t idx) const;
	string_view param_name_at(size_t idx) const;
	DefaultValueExpr param_default_value_at(size_t idx) const;
};


struct StructType
{
	TokenRange range;
	StructInstance *inst;
};

struct InlineStructType
{
	TokenRange range;
	StructItem *struct_;
};

static_assert(sizeof(Type) == 48, "sizeof(Type) is getting larger...");

string_view name_of(Path const &path, Module const *mod);
void print(Path const &path, Module const &mod, std::ostream &os);
void print(VarType const &var, std::ostream &os);
void print(Type const &type, Module const &mod, std::ostream &os);
string str(Type const &type, Module const &mod);
TokenRange token_range_of(Type const &type);


template<>
struct std::hash<::VarType>
{
	size_t operator () (::VarType var) const
	{
		size_t h = ::compute_hash(var.index());
		var | ::match
		{
			[&](TypeParameterVar v)
			{
				::combine_hashes(h, ::compute_hash(v.def));
			},
			[&](TypeDeductionVar v)
			{
				::combine_hashes(h, ::compute_hash(v.id));
			},
		};

		return h;
	}
};

inline bool operator == (VarType const &a, VarType const &b)
{
	if(a.index() != b.index())
		return false;

	return a | match
	{
		[&](TypeParameterVar const &p) { return p.def == std::get<TypeParameterVar>(b).def; },
		[&](TypeDeductionVar const &d) { return d.id == std::get<TypeDeductionVar>(b).id; },
	};
}

template<>
struct std::hash<Type>
{
	size_t operator () (Type const &type) const
	{
		size_t h = compute_hash(type.index());
		type | match
		{
			[&](BuiltinType const &t)
			{
				::combine_hashes(h, compute_hash((int)t.builtin));
			},
			[&](KnownIntType const &t)
			{
				::combine_hashes(h, compute_hash(t.low));
				::combine_hashes(h, compute_hash(t.high));
			},
			[&](VarType const &t)
			{
				::combine_hashes(h, compute_hash(t));
			},
			[&](PointerType const &t)
			{
				::combine_hashes(h, compute_hash((int)t.kind));
				::combine_hashes(h, compute_hash((int)t.mutability));
				::combine_hashes(h, compute_hash(*t.pointee));
			},
			[&](StructType const &t)
			{
				::combine_hashes(h, compute_hash(t.inst));
			},
			[&](ProcType const &t)
			{
				::combine_hashes(h, compute_hash(t.inst));
			},
			[&](UnionType const &t)
			{
				::combine_hashes(h, compute_hash(t.inst));
			},
			[&](ProcTypeUnresolved const&) { assert(!"hash<Type>: ProcTypeUnresolved"); },
			[&](UnionTypeUnresolved const&) { assert(!"hash<Type>: UnionTypeUnresolved"); },
			[&](Path const&) { assert(!"hash<Type>: Path"); },
			[&](InlineStructType const&) { assert(!"hash<InlineStructType>: Path"); },
		};

		return h;
	}
};


//--------------------------------------------------------------------
// Expressions
//--------------------------------------------------------------------
struct Expr;
struct Var;
class ProcInstance;

struct IntLiteralExpr
{
	TokenRange range;
	Int128 value;

	Type *NULLABLE type = nullptr;
};

struct BoolLiteralExpr
{
	TokenRange range;
	bool value;

	Type *NULLABLE type = nullptr;
};

enum class StringLiteralKind
{
	C
};

struct StringLiteralExpr
{
	TokenRange range;
	StringLiteralKind kind;
	string_view value;

	Type *NULLABLE type = nullptr;
};


enum class UnaryOp
{
	NOT = int(Lexeme::NOT),
	NEG = int(Lexeme::MINUS),
};

struct UnaryExpr
{
	TokenRange range;
	Expr *sub;
	UnaryOp op;

	Type *NULLABLE type = nullptr;
};


enum class BinaryOp
{
	ADD = int(Lexeme::PLUS),
	SUB = int(Lexeme::MINUS),
	MUL = int(Lexeme::STAR),
	DIV = int(Lexeme::SLASH),

	EQ = int(Lexeme::DOUBLE_EQ),
	LT = int(Lexeme::LT),
	LE = int(Lexeme::LE),
	GT = int(Lexeme::GT),
	GE = int(Lexeme::GE),
};

struct BinaryExpr
{
	TokenRange range;
	Expr *left;
	Expr *right;
	BinaryOp op;

	Type *NULLABLE type = nullptr;
};


// The current syntax for taking a mutable address is `&mut var`, which is quite long.
// Potential alternatives:
// - Ditch `mut`: If `var` is mutable, then `&var` results in a mutable pointer
// - Replace `&mut` with `!`: `&var` results in a constant pointer, while `!var` results in a
//   mutable pointer
struct AddressOfExpr
{
	TokenRange range;
	Expr *object;
	IsMutable mutability;

	Type *NULLABLE type = nullptr;
};

struct DerefExpr
{
	TokenRange range;
	Expr *addr;

	Type *NULLABLE type = nullptr;
};

struct IndexExpr
{
	TokenRange range;
	Expr *addr;
	Expr *index;

	Type *NULLABLE type = nullptr;
};

struct MemberAccessExpr
{
	TokenRange range;
	Expr *object;
	string_view member;

	Type *NULLABLE type = nullptr;
};

struct AssignmentExpr
{
	TokenRange range;
	Expr *lhs;
	Expr *rhs;

	Type *NULLABLE type = nullptr;
};

struct AsExpr
{
	TokenRange range;
	Expr *src_expr;
	Type *target_type;

	Type *NULLABLE type = nullptr;
};

struct ConstructorExpr
{
	TokenRange range;
	Type *ctor;

	Type *NULLABLE type = nullptr;
};

struct ProcExpr
{
	TokenRange range;
	ProcInstance *inst;

	Type *NULLABLE type = nullptr;
};

struct CallExpr
{
	TokenRange range;
	Expr *callable;
	FixedArray<struct Argument> *args;

	Type *NULLABLE type = nullptr;
};

struct SizeOfExpr
{
	TokenRange range;
	Type *subject;

	Type *NULLABLE type = nullptr;
};

struct MakeExpr
{
	TokenRange range;
	Expr *init;
	Expr *addr;

	Type *NULLABLE type = nullptr;
};

struct VarExpr
{
	TokenRange range;
	Var const *NULLABLE var = nullptr;

	Type *NULLABLE type = nullptr;
};

struct UnionInitExpr
{
	TokenRange range;
	Expr *alt_expr;

	// We have to store the alt_type instead of the alt_idx here because the order of the
	// alternatives may change during substitution. Additinally, some alternatives may be removed
	// if it turns out they are duplicates.
	Type *alt_type;

	Type *NULLABLE type = nullptr;
};


struct Expr : variant<
	IntLiteralExpr,
	BoolLiteralExpr,
	StringLiteralExpr,
	UnaryExpr,
	BinaryExpr,
	AddressOfExpr,
	DerefExpr,
	IndexExpr,
	MemberAccessExpr,
	AssignmentExpr,
	AsExpr,
	ConstructorExpr,
	ProcExpr,
	CallExpr,
	SizeOfExpr,
	MakeExpr,
	VarExpr,
	UnionInitExpr,
	Path
>
{
	using variant::variant;
};


struct Argument
{
	TokenRange range;
	Expr expr;
	string_view name{}; // May be empty

	int param_idx = 0; // Available after semantic analysis
};


void print(Expr const &expr, Module const &mod, std::ostream &os);
Type* type_of(Expr &expr);
Type const* type_of(Expr const &expr);
TokenRange token_range_of(Expr const &expr);


static_assert(sizeof(Expr) == 64, "sizeof(Expr) is getting larger...");


//--------------------------------------------------------------------
// Patterns
//--------------------------------------------------------------------
struct Pattern;

struct DerefPattern
{
	TokenRange range;
	Pattern *sub;

	Type *NULLABLE type = nullptr;
};

struct AddressOfPattern
{
	TokenRange range;
	Pattern *sub;
	IsMutable mutability;

	Type *NULLABLE type = nullptr;
};

struct VarPatternUnresolved
{
	TokenRange range;
	string_view name;
	IsMutable mutability;
};

struct VarPattern
{
	TokenRange range;
	Var *var = nullptr;

	Type *NULLABLE type = nullptr;
};

struct WildcardPattern
{
	TokenRange range;
	Type *NULLABLE type = nullptr;
};

struct ConstructorPattern
{
	TokenRange range;
	Type *ctor;
	FixedArray<struct PatternArgument> *args;
	bool has_parens;

	Type *NULLABLE type = nullptr;
};


struct Pattern : variant
<
	VarPatternUnresolved,
	VarPattern,
	DerefPattern,
	AddressOfPattern,
	ConstructorPattern,
	WildcardPattern
>
{
	template<typename T>
	Pattern(T &&t, Type *NULLABLE provided_type) :
		variant(std::forward<T>(t)),
		provided_type(provided_type) {}

	Type *NULLABLE provided_type;
};


struct PatternArgument
{
	Pattern pattern;
	string_view param_name; // May be empty

	int param_idx = 0; // Available after semantic analysis
};

TokenRange token_range_of(Pattern const &pattern);
Type& type_of(Pattern &pattern);
Type const& type_of(Pattern const &pattern);
void print(Pattern const &pattern, Module const &mod, std::ostream &os);

static_assert(sizeof(Pattern) == 56, "sizeof(Pattern) is getting larger...");


//--------------------------------------------------------------------
// Statements
//--------------------------------------------------------------------
using Stmt = variant<
	struct LetStmt,
	struct ExprStmt,
	struct BlockStmt,
	struct ReturnStmt,
	struct IfStmt,
	struct WhileStmt,
	struct MatchStmt
>;

struct LetStmt
{
	TokenRange range;
	Pattern *lhs;
	Expr *init_expr;
};

struct ExprStmt
{
	TokenRange range;
	Expr *expr;
};

struct BlockStmt
{
	TokenRange range;
	FixedArray<Stmt> *stmts;
};

struct ReturnStmt
{
	TokenRange range;
	Expr *NULLABLE ret_expr = nullptr;
};

struct IfStmt
{
	TokenRange range;
	Expr *condition;
	Stmt *then;
	Stmt *NULLABLE else_ = nullptr;
};

struct WhileStmt
{
	TokenRange range;
	Expr *condition;
	Stmt *body;
};


struct MatchStmt
{
	TokenRange range;
	Expr *expr;
	FixedArray<struct MatchArm> *arms;
};

struct MatchArm
{
	Pattern capture;
	Stmt stmt;

	// Available after semantic analysis
	int discr = -1;
};


void print(Stmt const &stmt, Module const &mod, std::ostream &os);

static_assert(sizeof(Stmt) == 40, "sizeof(Stmt) is getting larger...");


//--------------------------------------------------------------------
// Top-level items
//--------------------------------------------------------------------
struct SemaModule;
struct Struct;
struct Proc;
struct Alias;

struct Parameter
{
	TokenRange range;
	Type *NULLABLE type = nullptr;
	DefaultValueExpr default_value;
};

struct TypeParameter
{
	TokenRange range;
	string_view name;
};

struct ProcItem
{
	TokenRange range;
	string_view name;
	string_view receiver_name; // May be empty
	FixedArray<TypeParameter> *type_params = nullptr;
	FixedArray<Parameter> *params = nullptr;
	Type *NULLABLE ret_type = nullptr;
	Stmt *NULLABLE body = nullptr;
	bool is_extern = false;

	Proc *NULLABLE sema = nullptr; // Available after semantic analysis
};

using Member = variant<Parameter, struct StructItem*>;

struct StructItem
{
	TokenRange range;
	string_view name;
	FixedArray<TypeParameter> *type_params = nullptr;
	FixedArray<Member> *members = nullptr;
	bool is_implicit = false;
	bool ctor_without_parens = false;
	bool is_extern = false;
	int num_case_members = 0;

	int num_var_members() const { return members->count - num_case_members; }
	bool has_constructor() const { return num_case_members == 0; }

	Struct *NULLABLE sema = nullptr; // Available after semantic analysis
};

struct AliasItem
{
	TokenRange range;
	string_view name;
	FixedArray<TypeParameter> *type_params = nullptr;
	Type *aliased_type;

	Alias *NULLABLE sema = nullptr; // Available after semantic analysis
};

using TopLevelItem = variant<
	ProcItem,
	StructItem,
	AliasItem
>;

class TypeEnv;
struct ConstraintSystem;

class EventLogger
{
public:
	EventLogger(Module *mod, std::ostream &os);
	~EventLogger();

	// Compiler pass events
	void on_declare_items_start();
	void on_declare_items_end();
	void on_resolve_names_start();
	void on_resolve_names_end();
	void on_typecheck_start();
	void on_typecheck_end();
	void on_layout_computation_start();
	void on_layout_computation_end();

	// Struct events
	void on_struct_substitution_start(StructInstance *inst);
	void on_struct_substitution_replaced(StructInstance *inst);
	void on_struct_substitution_noop();
	void on_struct_substitution_end();
	void on_struct_layout_computation_start(StructInstance *inst);
	void on_struct_layout_computation_end();
	void on_struct_register(StructInstance *inst);

	// Procedure events
	void on_proc_register(ProcInstance *inst);

	// Expression events
	void on_expr_start(Expr const &expr);
	void on_expr_end();

	// Data events
	void on_data(TypeEnv const &env);
	void on_data(ConstraintSystem const &sys);

private:
	Module *m_mod;
	std::ostream &m_os;
};

#define LOGGER(logger, event, ...) do { if(logger) (logger)->event(__VA_ARGS__); } while(false)

struct Module
{
	List<TopLevelItem> *items;
	vector<Token> tokens;
	string_view source;
	optional<EventLogger> logger{};

	std::unique_ptr<SemaModule> NULLABLE sema{}; // Available after semantic analysis
};


string_view name_of(Parameter const &param, Module const *mod);
void print(TopLevelItem const &item, Module const &mod, std::ostream &os);
void print(Module const &mod, std::ostream &os);


//==============================================================================
// Lexing
//==============================================================================
class LexingError : public std::runtime_error
{
public:
	explicit LexingError(string const &msg) :
		std::runtime_error{msg} {}
};

vector<Token> tokenize(string_view source);


//==============================================================================
// Parsing
//==============================================================================
class ParseError : public std::runtime_error
{
public:
	ParseError(std::string const &msg) :
		std::runtime_error{msg} {}
};

struct Parser
{
	explicit Parser(string_view source, span<Token> tokens) :
		tokens{tokens},
		source(source) {}

	Token const& tok() const
	{
		assert(pos < tokens.size());
		return tokens[pos];
	}

	Token const& tok(TokenIdx idx) const
	{
		assert(idx.value < tokens.size());
		return tokens[idx.value];
	}

	void rewind()
	{
		assert(pos > 0);
		pos -= 1;
	}

	optional<Lexeme> peek(size_t i = 0) const
	{
		if(pos + i < tokens.size())
			return tokens[pos + i].kind;

		return nullopt;
	}

	Lexeme tok_kind() const
	{
		assert(pos < tokens.size());
		return tokens[pos].kind;
	}

	Token const& next()
	{
		assert(pos < tokens.size());
		return tokens[pos++];
	}

	SourceLocation prev_loc() const
	{
		assert(pos > 0 && pos <= tokens.size());
		return tokens[pos - 1].span.end;
	}

	Token const& prev_tok() const
	{
		assert(pos > 0 && pos <= tokens.size());
		return tokens[pos - 1];
	}

	SourceLocation location() const
	{
		assert(pos < tokens.size());
		return tokens[pos].span.begin;
	}

	TokenIdx tok_idx() const { return TokenIdx(pos); }
	TokenIdx prev_tok_idx() const { return TokenIdx(pos > 0 ? pos - 1 : 0); }

	span<Token> tokens;
	string_view source;
	size_t pos = 0;
};

Module parse_module(string_view source, Memory M);
