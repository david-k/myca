#pragma once

#include <cassert>
#include <optional>
#include <ostream>
#include <span>
#include <string>
#include <string_view>
#include <variant>
#include <vector>
#include <stdexcept>
#include <memory>

#include "utils.hpp"


using std::optional;
using std::nullopt;
using std::string;
using std::string_view;
using std::variant;
using std::vector;
using std::span;


//==============================================================================
// Tokens
//==============================================================================
enum class Lexeme
{
	IDENTIFIER,
	INT_LITERAL,
	C_STRING_LITERAL,
	TRUE,
	FALSE,

	DOT,
	COMMA,
	COLON,
	SEMICOLON,
	CIRCUMFLEX,
	AMPERSAND,
	QUESTIONMARK,
	BANG,
	SINGLE_QUOTE,
	AT,
	BAR,
	LEFT_PAREN,
	RIGHT_PAREN,
	LEFT_BRACE,
	RIGHT_BRACE,
	LEFT_BRACKET,
	RIGHT_BRACKET,

	THIN_ARROW,

	PLUS,
	MINUS,
	UNARY_MINUS, // Not actually generated by the lexer. Only used for get_operator_info()
	SLASH,
	STAR,
	EQ,
	COLON_EQ,
	DOUBLE_EQ,
	LT,
	LE,
	GT,
	GE,

	NOT,

	LET,
	PROC,
	STRUCT,
	CASE,
	IMPLICIT,

	TYPE_NEVER,
	TYPE_BOOL,
	TYPE_UNIT,
	TYPE_I8,
	TYPE_U8,
	TYPE_I32,
	TYPE_U32,
	TYPE_ISIZE,
	TYPE_USIZE,

	IF,
	ELSE,
	WHILE,
	MATCH,
	RETURN,

	AS,
	MUT,

	TYPEALIAS,
	EXTERN,

	SIZE_OF,
	MAKE,

	END,
};


struct SourceLocation
{
	size_t pos = 0;
	int line = 0;
	int col = 0;
};


struct SourceSpan
{
	SourceLocation begin;
	SourceLocation end;
};

struct Token
{
	Lexeme kind;

	union
	{
		uint64_t int_val{};
		string_view str_val;
	} value{};

	SourceSpan span;
};


string_view str(Lexeme tok);
inline string str(SourceLocation loc) { return std::to_string(loc.line) + ":" + std::to_string(loc.col); }


//==============================================================================
// AST
//==============================================================================
struct Module;

struct TokenIdx { uint32_t value; };
struct TokenRange { TokenIdx first{}, last{}; };

static constexpr TokenIdx INVALID_TOKEN_IDX = TokenIdx(-1);
static constexpr TokenRange UNKNOWN_TOKEN_RANGE = TokenRange(INVALID_TOKEN_IDX, INVALID_TOKEN_IDX);


//--------------------------------------------------------------------
// Types
//--------------------------------------------------------------------
class StructInstance;
struct UnionInstance;
struct ProcTypeInstance;
struct TypeParameter;
struct Expr;


struct TypeParameterVar
{
	TypeParameter const *def;

	friend bool operator == (TypeParameterVar a, TypeParameterVar b) = default;
};

struct TypeDeductionVar
{
	uint32_t id;

	friend bool operator == (TypeDeductionVar a, TypeDeductionVar b) = default;
};

using VarType = variant<TypeParameterVar, TypeDeductionVar>;

using Type = variant
<
	struct BuiltinType,
	struct KnownIntType,
	struct PointerType,
	struct ManyPointerType,
	struct ProcType,
	struct StructType,
	struct UnionType,
	VarType,

	// Unresolved types
	struct Path,
	struct ProcTypeUnresolved,
	struct UnionTypeUnresolved
>;

enum class BuiltinTypeDef
{
	NEVER,
	UNIT,
	BOOL,
	I8,
	U8,
	I32,
	U32,
	ISIZE,
	USIZE,
};

struct BuiltinType
{
	TokenRange range;
	BuiltinTypeDef builtin;
};

struct KnownIntType
{
	Int128 low;
	Int128 high;
};

struct Path
{
	TokenRange range;
	FixedArray<Type> *type_args = nullptr;
	Path *NULLABLE child = nullptr;
};

enum class IsMutable
{
	YES,
	NO,
};

struct PointerType
{
	TokenRange range;
	Type *pointee;
	IsMutable mutability;
};

struct ManyPointerType
{
	TokenRange range;
	Type *pointee;
	IsMutable mutability;
};

struct UnionTypeUnresolved
{
	TokenRange range;
	FixedArray<Type> *alternatives = nullptr;
};

struct UnionType
{
	TokenRange range;
	UnionInstance *inst;
};

struct ProcTypeUnresolved
{
	TokenRange range;
	Type *ret;
	FixedArray<Type> *params = nullptr;
};


struct NoDefaultValue {};
struct ExprPending {};
struct DefaultValueExpr : variant<NoDefaultValue, ExprPending, Expr*>
{
	using variant::variant;

	Expr* try_get_expr() const
	{
		return *this | match
		{
			[](Expr *expr) { return expr; },
			[](auto) { return (Expr*)nullptr; },
		};
	}

	NO_DANGLING Expr& get_expr() const
	{
		Expr *expr = try_get_expr();
		assert(expr && "DefaultValueExpr has no expr");
		return *expr;
	}

	explicit operator bool () const
	{
		return *this | match
		{
			[](NoDefaultValue) { return false; },
			[](auto) { return true; },
		};
	}

	DefaultValueExpr clone(Arena &arena) const;
};

struct ProcTypeParamAux
{
	string_view name;
	DefaultValueExpr default_value;
};

struct ProcType
{
	TokenRange range;
	ProcTypeInstance *inst;

	// This is used for typechecking procedure/constructor calls, but is irrelevant for deciding
	// whether two ProcTypes are equal.
	variant<class ProcInstance*, class StructInstance*> callable;

	size_t param_count() const;
	Type* param_type_at(size_t idx) const;
	string_view param_name_at(size_t idx) const;
	DefaultValueExpr param_default_value_at(size_t idx) const;
};


struct StructType
{
	TokenRange range;
	StructInstance *inst;
};


string_view name_of(Path const &path, Module const *mod);
void print(Path const &path, Module const &mod, std::ostream &os);
void print(Type const &type, Module const &mod, std::ostream &os);
string str(Type const &type, Module const &mod);
TokenRange token_range_of(Type const &type);

static_assert(sizeof(Type) == 48, "sizeof(Type) is getting larger...");
template<>
struct std::hash<::VarType>
{
	size_t operator () (::VarType var) const
	{
		size_t h = ::compute_hash(var.index());
		var | ::match
		{
			[&](TypeParameterVar v)
			{
				::combine_hashes(h, ::compute_hash(v.def));
			},
			[&](TypeDeductionVar v)
			{
				::combine_hashes(h, ::compute_hash(v.id));
			},
		};

		return h;
	}
};

template<>
struct std::hash<Type>
{
	size_t operator () (Type const &type) const
	{
		size_t h = compute_hash(type.index());
		type | match
		{
			[&](BuiltinType const &t)
			{
				::combine_hashes(h, compute_hash((int)t.builtin));
			},
			[&](KnownIntType const &t)
			{
				::combine_hashes(h, compute_hash(t.low));
				::combine_hashes(h, compute_hash(t.high));
			},
			[&](VarType const &t)
			{
				::combine_hashes(h, compute_hash(t));
			},
			[&](PointerType const &t)
			{
				::combine_hashes(h, compute_hash((int)t.mutability));
				::combine_hashes(h, compute_hash(*t.pointee));
			},
			[&](ManyPointerType const &t)
			{
				::combine_hashes(h, compute_hash((int)t.mutability));
				::combine_hashes(h, compute_hash(*t.pointee));
			},
			[&](StructType const &t)
			{
				::combine_hashes(h, compute_hash(t.inst));
			},
			[&](ProcType const &t)
			{
				::combine_hashes(h, compute_hash(t.inst));
			},
			[&](UnionType const &t)
			{
				::combine_hashes(h, compute_hash(t.inst));
			},
			[&](ProcTypeUnresolved const&) { assert(!"hash<Type>: ProcTypeUnresolved"); },
			[&](UnionTypeUnresolved const&) { assert(!"hash<Type>: UnionTypeUnresolved"); },
			[&](Path const&) { assert(!"hash<Type>: Path"); },
		};

		return h;
	}
};


//--------------------------------------------------------------------
// Expressions
//--------------------------------------------------------------------
struct Expr;
struct Var;
class ProcInstance;

struct IntLiteralExpr
{
	TokenRange range;
	Int128 value;

	Type *NULLABLE type = nullptr;
};

struct BoolLiteralExpr
{
	TokenRange range;
	bool value;

	Type *NULLABLE type = nullptr;
};

enum class StringLiteralKind
{
	C
};

struct StringLiteralExpr
{
	TokenRange range;
	StringLiteralKind kind;
	string_view value;

	Type *NULLABLE type = nullptr;
};


enum class UnaryOp
{
	NOT = int(Lexeme::NOT),
	NEG = int(Lexeme::MINUS),
};

struct UnaryExpr
{
	TokenRange range;
	Expr *sub;
	UnaryOp op;

	Type *NULLABLE type = nullptr;
};


enum class BinaryOp
{
	ADD = int(Lexeme::PLUS),
	SUB = int(Lexeme::MINUS),
	MUL = int(Lexeme::STAR),
	DIV = int(Lexeme::SLASH),

	EQ = int(Lexeme::DOUBLE_EQ),
	LT = int(Lexeme::LT),
	LE = int(Lexeme::LE),
	GT = int(Lexeme::GT),
	GE = int(Lexeme::GE),
};

struct BinaryExpr
{
	TokenRange range;
	Expr *left;
	Expr *right;
	BinaryOp op;

	Type *NULLABLE type = nullptr;
};


// The current syntax for taking a mutable address is `&mut var`, which is quite long.
// Potential alternatives:
// - Ditch `mut`: If `var` is mutable, then `&var` results in a mutable pointer
// - Replace `&mut` with `!`: `&var` results in a constant pointer, while `!var` results in a
//   mutable pointer
struct AddressOfExpr
{
	TokenRange range;
	Expr *object;
	IsMutable mutability;

	Type *NULLABLE type = nullptr;
};

struct DerefExpr
{
	TokenRange range;
	Expr *addr;

	Type *NULLABLE type = nullptr;
};

struct IndexExpr
{
	TokenRange range;
	Expr *addr;
	Expr *index;

	Type *NULLABLE type = nullptr;
};

struct MemberAccessExpr
{
	TokenRange range;
	Expr *object;
	string_view member;

	Type *NULLABLE type = nullptr;
};

struct AssignmentExpr
{
	TokenRange range;
	Expr *lhs;
	Expr *rhs;

	Type *NULLABLE type = nullptr;
};

struct AsExpr
{
	TokenRange range;
	Expr *src_expr;
	Type *target_type;

	Type *NULLABLE type = nullptr;
};

struct ConstructorExpr
{
	TokenRange range;
	Type *ctor;

	Type *NULLABLE type = nullptr;
};

struct ProcExpr
{
	TokenRange range;
	ProcInstance *inst;

	Type *NULLABLE type = nullptr;
};

struct CallExpr
{
	TokenRange range;
	Expr *callable;
	FixedArray<struct Argument> *args;

	Type *NULLABLE type = nullptr;
};

struct SizeOfExpr
{
	TokenRange range;
	Type *subject;

	Type *NULLABLE type = nullptr;
};

struct MakeExpr
{
	TokenRange range;
	Expr *init;
	Expr *addr;

	Type *NULLABLE type = nullptr;
};

struct VarExpr
{
	TokenRange range;
	Var const *NULLABLE var = nullptr;

	Type *NULLABLE type = nullptr;
};


struct Expr : variant<
	struct IntLiteralExpr,
	struct BoolLiteralExpr,
	struct StringLiteralExpr,
	struct UnaryExpr,
	struct BinaryExpr,
	struct AddressOfExpr,
	struct DerefExpr,
	struct IndexExpr,
	struct MemberAccessExpr,
	struct AssignmentExpr,
	struct AsExpr,
	struct ConstructorExpr,
	struct ProcExpr,
	struct CallExpr,
	struct SizeOfExpr,
	struct MakeExpr,
	struct VarExpr,
	Path
>
{
	using variant::variant;
};


struct Argument
{
	TokenRange range;
	Expr expr;
	string_view name{}; // May be empty

	int param_idx = 0; // Available after semantic analysis
};


void print(Expr const &expr, Module const &mod, std::ostream &os);
Type* type_of(Expr &expr);
Type const* type_of(Expr const &expr);
TokenRange token_range_of(Expr const &expr);


static_assert(sizeof(Expr) == 64, "sizeof(Expr) is getting larger...");


//--------------------------------------------------------------------
// Patterns
//--------------------------------------------------------------------
struct Pattern;

struct DerefPattern
{
	TokenRange range;
	Pattern *sub;

	Type *NULLABLE type = nullptr;
};

struct AddressOfPattern
{
	TokenRange range;
	Pattern *sub;
	IsMutable mutability;

	Type *NULLABLE type = nullptr;
};

struct VarPatternUnresolved
{
	TokenRange range;
	string_view name;
	IsMutable mutability;
};

struct VarPattern
{
	TokenRange range;
	Var *var = nullptr;

	Type *NULLABLE type = nullptr;
};

struct WildcardPattern
{
	TokenRange range;
	Type *NULLABLE type = nullptr;
};

struct ConstructorPattern
{
	TokenRange range;
	Type *ctor;
	FixedArray<struct PatternArgument> *args;
	bool has_parens;

	Type *NULLABLE type = nullptr;
};


struct Pattern : variant
<
	VarPatternUnresolved,
	VarPattern,
	DerefPattern,
	AddressOfPattern,
	ConstructorPattern,
	WildcardPattern
>
{
	template<typename T>
	Pattern(T &&t, Type *NULLABLE provided_type) :
		variant(std::forward<T>(t)),
		provided_type(provided_type) {}

	Type *NULLABLE provided_type;
};


struct PatternArgument
{
	Pattern pattern;
	string_view param_name; // May be empty

	int param_idx = 0; // Available after semantic analysis
};

TokenRange token_range_of(Pattern const &pattern);
Type& type_of(Pattern &pattern);
Type const& type_of(Pattern const &pattern);
void print(Pattern const &pattern, Module const &mod, std::ostream &os);

static_assert(sizeof(Pattern) == 56, "sizeof(Pattern) is getting larger...");


//--------------------------------------------------------------------
// Statements
//--------------------------------------------------------------------
using Stmt = variant<
	struct LetStmt,
	struct ExprStmt,
	struct BlockStmt,
	struct ReturnStmt,
	struct IfStmt,
	struct WhileStmt,
	struct MatchStmt
>;

struct LetStmt
{
	TokenRange range;
	Pattern *lhs;
	Expr *init_expr;
};

struct ExprStmt
{
	TokenRange range;
	Expr *expr;
};

struct BlockStmt
{
	TokenRange range;
	FixedArray<Stmt> *stmts;
};

struct ReturnStmt
{
	TokenRange range;
	Expr *NULLABLE ret_expr = nullptr;
};

struct IfStmt
{
	TokenRange range;
	Expr *condition;
	Stmt *then;
	Stmt *NULLABLE else_ = nullptr;
};

struct WhileStmt
{
	TokenRange range;
	Expr *condition;
	Stmt *body;
};


struct MatchStmt
{
	TokenRange range;
	Expr *expr;
	FixedArray<struct MatchArm> *arms;
};

struct MatchArm
{
	Pattern capture;
	Stmt stmt;

	// Available after semantic analysis
	int discr = -1;
};


void print(Stmt const &stmt, Module const &mod, std::ostream &os);

static_assert(sizeof(Stmt) == 40, "sizeof(Stmt) is getting larger...");


//--------------------------------------------------------------------
// Top-level items
//--------------------------------------------------------------------
struct SemaModule;
struct Struct;
struct Proc;
struct Alias;

struct Parameter
{
	TokenRange range;
	Type *NULLABLE type = nullptr;
	DefaultValueExpr default_value;
};

struct TypeParameter
{
	TokenRange range;
	string_view name;
};

struct ProcItem
{
	TokenRange range;
	string_view name;
	string_view receiver_name; // May be empty
	FixedArray<TypeParameter> *type_params = nullptr;
	FixedArray<Parameter> *params = nullptr;
	Type *NULLABLE ret_type = nullptr;
	Stmt *NULLABLE body = nullptr;
	bool is_extern = false;

	Proc *NULLABLE sema = nullptr;
};

using Member = variant<Parameter, struct StructItem*>;

struct StructItem
{
	TokenRange range;
	string_view name;
	FixedArray<TypeParameter> *type_params = nullptr;
	FixedArray<Member> *members = nullptr;
	bool is_implicit = false;
	bool ctor_without_parens = false;
	bool is_extern = false;

	int num_case_members = 0;
	Struct *NULLABLE sema = nullptr;

	int num_var_members() const { return members->count - num_case_members; }
	bool has_constructor() const { return num_case_members == 0; }
};

struct AliasItem
{
	TokenRange range;
	string_view name;
	FixedArray<TypeParameter> *type_params = nullptr;
	Type *aliased_type;

	Alias *NULLABLE sema = nullptr;
};

using TopLevelItem = variant<
	ProcItem,
	StructItem,
	AliasItem
>;

class EventLogger
{
public:
	EventLogger(Module *mod, std::ostream &os) :
		m_mod(mod),
		m_os(os) {}

	void on_declare_items_start();
	void on_declare_items_end();
	void on_resolve_names_start();
	void on_resolve_names_end();
	void on_typecheck_start();
	void on_typecheck_end();

	void on_struct_substitution_start(StructInstance *inst, class TypeEnv const &subst);
	void on_struct_substitution_replaced(StructInstance *inst);
	void on_struct_substitution_noop();
	void on_struct_substitution_end();

	void on_register_struct(StructInstance *inst);
	void on_register_proc(ProcInstance *inst);

	void on_expr_start(Expr const &expr);
	void on_expr_end();


	// Layout computation pass
	//------------------------------
	void on_start_layout_computation_pass();
	void on_end_layout_computation_pass();

	void on_start_layout_computation(StructInstance *inst);
	void on_end_layout_computation();

private:
	Module *m_mod;
	std::ostream &m_os;
};

#define LOGGER(logger, event, ...) do { if(logger) (logger)->event(__VA_ARGS__); } while(false)

struct Module
{
	List<TopLevelItem> *items;
	vector<Token> tokens;
	string_view source;

	std::unique_ptr<SemaModule> NULLABLE sema;
	optional<EventLogger> NULLABLE logger{};
};


string_view name_of(Parameter const &param, Module const *mod);
void print(TopLevelItem const &item, Module const &mod, std::ostream &os);
void print(Module const &mod, std::ostream &os);


//==============================================================================
// Lexing
//==============================================================================
class LexingError : public std::runtime_error
{
public:
	explicit LexingError(string const &msg) :
		std::runtime_error{msg} {}
};

vector<Token> tokenize(string_view source);


//==============================================================================
// Parsing
//==============================================================================
class ParseError : public std::runtime_error
{
public:
	ParseError(std::string const &msg) :
		std::runtime_error{msg} {}
};

struct Parser
{
	explicit Parser(string_view source, span<Token> tokens) :
		tokens{tokens},
		source(source) {}

	Token const& tok() const
	{
		assert(pos < tokens.size());
		return tokens[pos];
	}

	Token const& tok(TokenIdx idx) const
	{
		assert(idx.value < tokens.size());
		return tokens[idx.value];
	}

	void rewind()
	{
		assert(pos > 0);
		pos -= 1;
	}

	optional<Lexeme> peek(size_t i = 0)
	{
		if(pos + i < tokens.size())
			return tokens[pos + i].kind;

		return nullopt;
	}

	Lexeme tok_kind() const
	{
		assert(pos < tokens.size());
		return tokens[pos].kind;
	}

	Token const& next()
	{
		assert(pos < tokens.size());
		return tokens[pos++];
	}

	SourceLocation prev_loc() const
	{
		assert(pos > 0 && pos <= tokens.size());
		return tokens[pos - 1].span.end;
	}

	Token const& prev_tok() const
	{
		assert(pos > 0 && pos <= tokens.size());
		return tokens[pos - 1];
	}

	SourceLocation location() const
	{
		assert(pos < tokens.size());
		return tokens[pos].span.begin;
	}

	TokenIdx tok_idx() const { return TokenIdx(pos); }
	TokenIdx prev_tok_idx() const { return TokenIdx(pos > 0 ? pos - 1 : 0); }

	span<Token> tokens;
	string_view source;
	size_t pos = 0;
};

Module parse_module(string_view source, Memory M);
