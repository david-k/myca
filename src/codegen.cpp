#include "codegen.hpp"

#include "semantics.hpp"


//==============================================================================
static void generate_c(Type const &type, CBackend &backend);

CBackend::CBackend(std::ostream &os) :
	os(os)
{
	*this << "#include <stdint.h>" << LineEnd;
	*this << "#include <stddef.h>" << LineEnd;
	*this << "#include <stdbool.h>" << LineEnd;
	*this << "#include <stdlib.h>" << LineEnd;
	*this << "#include <stdio.h>" << LineEnd;
	*this << "#include <limits.h>" << LineEnd;
	*this << "#include <assert.h>" << LineEnd;
	*this << "#include <errno.h>" << LineEnd;
	*this << LineEnd;

	// In Myca, `c_char` is defined to be an alias for `i8`.
	// Here, we make sure that this matches the type of `char` in C.
	*this << "#if CHAR_BIT != 8" << LineEnd;
	*this << "    #error \"Unexpected CHAR_BIT\"" << LineEnd;
	*this << "#endif" << LineEnd;
	*this << "#if CHAR_MIN != -128" << LineEnd;
	*this << "    #error \"Unexpected CHAR_MIN\"" << LineEnd;
	*this << "#endif" << LineEnd;
	*this << "#if CHAR_MAX != 127" << LineEnd;
	*this << "    #error \"Unexpected CHAR_MAX\"" << LineEnd;
	*this << "#endif" << LineEnd;

	// This disables warnings generated by GCC when forward-declaring builtin C functions with
	// non-conforming type signatures.
	// This is needed because we define `c_char` as either `signed char` or `unsigned char`,
	// both of which are distinct from `char`.
	// For example, this declaration in Myca
	//
	//     extern proc puts(str: [^]c_char) -> i32;
	//
	// generates the following C code:
	//
	//     typedef int8_t c_char;
	//     int32_t puts(c_char const* str);
	//
	// This differs from the standard definition of `puts(char const *str)`.
	*this << LineEnd;
	*this << "#if defined(__clang__)" << LineEnd;
	*this << "   // Nothing yet" << LineEnd;
	*this << "#elif defined(__GNUC__)" << LineEnd;
	*this << "    #pragma GCC diagnostic ignored \"-Wbuiltin-declaration-mismatch\"" << LineEnd;
	*this << "#endif" << LineEnd;
	*this << LineEnd;

	*this << LineEnd;
	*this << "typedef struct Never { char _; } Never;" << LineEnd;
	*this << LineEnd;

	*this << LineEnd;
	*this << "typedef struct Unit { char _; } Unit;" << LineEnd;
	*this << LineEnd;

	*this << LineEnd;
	*this << "int get_errno() { return errno; }" << LineEnd;
	*this << LineEnd;

	*this << LineEnd;
	*this << "__attribute__((noreturn)) void fatal(char const *msg) { fputs((char const*)msg, stderr); exit(1); }" << LineEnd;
	*this << LineEnd;
}

CBackend& CBackend::operator << (LineEnd_Tag)
{
	os << "\n";
	insert_indent = true;
	return *this;
}

CBackend& CBackend::operator << (Type const &type)
{
	generate_c(type, *this);
	return *this;
}


//==============================================================================
// CStruct
//==============================================================================
struct CMemberNormal { string name; };
struct CMemberConst { string name; size_t value; };
struct CMemberPadding {};

using CMemberKind = variant<CMemberNormal, CMemberConst, CMemberPadding>;

struct CMember
{
	CMemberKind kind;
	Type type;

	CMember(string const &name, Type type) :
		kind(CMemberNormal(name)), type(type) {}

	CMember(string name, optional<size_t> value, Type type) :
		kind(value ?
			CMemberKind(CMemberConst(name, *value)) :
			CMemberKind(CMemberNormal(name))
		),
		type(type) {}

	CMember(Type type) :
		kind(CMemberPadding()), type(type) {}


	CMember(CMember const &rhs) :
		kind(rhs.kind),
		type(rhs.type) {}
};

struct CStruct
{
	string name;
	string constructor_name;
	MemoryLayout cur_layout{};
	vector<CMember> members;

	explicit CStruct(string const &name, string const &constructor_name) :
		name(name),
		constructor_name(constructor_name) {}

	size_t add(CMember &&m)
	{
		cur_layout.extend(compute_layout(m.type));
		members.push_back(std::move(m));
		return members.size() - 1;
	}
};

void generate_c_struct_def(CStruct const &cstruct, CBackend &backend)
{
	// In Myca, types can have zero alignment (e.g., Never), but this is not allowed in C.
	size_t alignment = std::max(cstruct.cur_layout.alignment, size_t(1));
	backend << "struct " << "__attribute__((aligned(" << alignment << "))) " << cstruct.name << LineEnd << "{" << LineEnd;
	backend.increase_indent();

	for(CMember const &member: cstruct.members)
	{
		backend << member.type << " ";
		member.kind | match
		{
			[&](CMemberNormal const &m) { backend << m.name; },
			[&](CMemberConst const &m) { backend << m.name; },
			[&](CMemberPadding) { backend << backend.new_tmp_var(); },
		};
		backend << ";" << LineEnd;
	}

	if(cstruct.members.empty())
		backend << "char dummy;" << LineEnd;

	backend.decrease_indent();
	backend << "};" << LineEnd;
}


//==============================================================================
// Name mangling
//==============================================================================

// All mangled Myca symbols start with '_Y'.
//
// <symbol> ::= '_Y' <kind> <path-segment>+
//
// <kind> ::= 'T'  // type
//          | 'F'  // Procedure
//          | 'C'  // constructor
//
// <path-segment> ::= <id-segment> | <type-segment>
//
// <id-segment> ::= <num>                   // length of the following identifier
//                  <identifier>
//                  ('G' <path-segment>+ 'E')*  // Generic type arguments start with 'G' and ends with 'E'
//
// <type-segment> ::= 'P' 'm'? <path-segment>  // Pointer
//                  | 'M' 'm'? <path-segment>  // Many pointer
//                  | 'U' <path-segment>+ 'E'  // Union type

static string mangle_type_segment(Type const &type);

static string mangle_type_args(TypeArgList const &types)
{
	string mangled;
	for(Type const &arg: *types.args)
		mangled += 'G' + mangle_type_segment(arg) + 'E';

	return mangled;
}

static string mangle_union_type_segment(UnionType const &union_)
{
	(void)union_;
	assert(!"[TODO] mangle_union_type_segment");

	/*string mangled = "U";
	for(Type const &alt: union_.alternatives())
		mangled += mangle_type_segment(alt);

	return mangled + "E";*/
}

static string mangle_type_segment(Type const &type)
{
	return type | match
	{
		[&](BuiltinType const &t) -> string
		{
			switch(t.builtin)
			{
				case BuiltinTypeDef::NEVER: return "5Never";
				case BuiltinTypeDef::UNIT: return "4Unit";
				case BuiltinTypeDef::BOOL: return "4bool";
				case BuiltinTypeDef::I8: return "2i8";
				case BuiltinTypeDef::U8: return "2u8";
				case BuiltinTypeDef::I32: return "3i32";
				case BuiltinTypeDef::U32: return "3u32";
				case BuiltinTypeDef::ISIZE: return "5isize";
				case BuiltinTypeDef::USIZE: return "5usize";
			}

			UNREACHABLE;
		},
		[&](VarType const&) -> string { assert(!"mangle_type_segment: VarType"); },
		[&](PointerType const &t)
		{
			string mangled = "P";
			if(t.mutability == IsMutable::YES)
				mangled += "m";

			return mangled + mangle_type_segment(*t.pointee);
		},
		[&](ManyPointerType const &t)
		{
			string mangled = "M";
			if(t.mutability == IsMutable::YES)
				mangled += "m";

			return mangled + mangle_type_segment(*t.pointee);
		},
		[&](StructType const &struct_)
		{
			string segment = std::to_string(struct_.inst->struct_()->name.length()) + struct_.inst->struct_()->name;
			segment += mangle_type_args(struct_.inst->type_args());

			if(struct_.inst->parent())
				return mangle_type_segment(StructType(UNKNOWN_TOKEN_RANGE, struct_.inst->parent())) + segment;

			return segment;
		},
		[&](ProcType const&) -> string { assert(!"mangle_type_segment: ProcType: TODO"); },
		[&](UnionType const &t) -> string
		{
			return mangle_union_type_segment(t);
		},

		[&](KnownIntType const&) -> string { assert(!"mangle_type_segment: KnownIntType"); },
		[&](ProcTypeUnresolved const&) -> string { assert(!"mangle_type_segment: ProcTypeUnresolved"); },
		[&](UnionTypeUnresolved const&) -> string { assert(!"mangle_type_segment: UnionTypeUnresolved"); },
		[&](Path const&) -> string { assert(!"mangle_type_segment: Path"); },
	};
}


static string mangle_type(Type const &type)
{
	return "_YT" + mangle_type_segment(type);
}

/*static string mangle_union_type(UnionType const &union_)
{
	return "_YT" + mangle_union_type_segment(union_);
}*/

static string mangle_constructor(Type const &type)
{
	return "_YC" + mangle_type_segment(type);
}

static string mangle_procedure(ProcInstance const *proc)
{
	if(proc->proc()->name == "main" || not proc->proc()->body)
		return string(proc->proc()->name);

	string mangled = std::to_string(proc->proc()->name.length()) + proc->proc()->name;
	mangled += mangle_type_args(proc->type_args());

	return "_YF" + mangled;
}


//==============================================================================
// Types
//==============================================================================
static string generate_c_to_str(BuiltinTypeDef const &type)
{
	switch(type)
	{
		case BuiltinTypeDef::NEVER: return "Never";
		case BuiltinTypeDef::UNIT: return "Unit";
		case BuiltinTypeDef::BOOL: return "bool";
		case BuiltinTypeDef::I8: return "int8_t";
		case BuiltinTypeDef::U8: return "uint8_t";
		case BuiltinTypeDef::I32: return "int32_t";
		case BuiltinTypeDef::U32: return "uint32_t";
		case BuiltinTypeDef::USIZE: return "size_t";
		case BuiltinTypeDef::ISIZE: return "ptrdiff_t";
	}

	UNREACHABLE;
}

static string generate_c_to_str(Type const &type)
{
	return type | match
	{
		[&](BuiltinType const &t) { return generate_c_to_str(t.builtin); },
		[&](VarType const&) -> string { assert(!"generate_c_to_str: VarType"); },
		[&](PointerType const &t)
		{
			string type_str = generate_c_to_str(*t.pointee);
			if(t.mutability == IsMutable::NO)
				type_str += " const";

			return type_str + "*";
		},
		[&](ManyPointerType const &t)
		{
			string type_str = generate_c_to_str(*t.pointee);
			if(t.mutability == IsMutable::NO)
				type_str += " const";

			return type_str + "*";
		},
		[&](StructType const &t)
		{
			if(t.inst->struct_()->name == "c_void")
				return "void"s;

			if(t.inst->struct_()->name == "c_char")
				return "char"s;

			if(Type const *pointee = is_optional_ptr(t.inst))
				return generate_c_to_str(*pointee);

			if(t.inst->struct_()->is_extern)
				return string(t.inst->struct_()->name);

			return "struct " + mangle_type(type);
		},
		[&](ProcType const&) -> string { assert(!"generate_c_to_str: ProcType: TODO"); },
		[&](UnionType const&) -> string { return "struct " + mangle_type(type); },

		[&](KnownIntType const&) -> string { assert(!"generate_c_to_str: KnownIntType"); },
		[&](ProcTypeUnresolved const&) -> string { assert(!"generate_c_to_str: ProcTypeUnresolved"); },
		[&](UnionTypeUnresolved const&) -> string { assert(!"generate_c_to_str: UnionTypeUnresolved"); },
		[&](Path const&) -> string { assert(!"generate_c_to_str: Path"); },
	};
}

static void generate_c(Type const &type, CBackend &backend)
{
	backend << generate_c_to_str(type);
}


//==============================================================================
// Expressions
//==============================================================================
string generate_c(Expr const &expr, CBackend &backend, bool need_result = true);
void generate_c(Stmt const &stmt, CBackend &backend);
void generate_c_pattern(Pattern const &lhs_pattern, string const &rhs_expr, Type const &rhs_type, CBackend &backend);

string generate_c_cast(Type const &target_type, string const &expr, Type const &expr_type)
{
	if(equiv(target_type, expr_type) || expr == "NULL")
		return expr;

	string type_val = generate_c_to_str(target_type);

	if(is<StructType>(target_type) and not is_optional_ptr(target_type))
		return "(*(" + type_val + "*)&(" + expr + "))";
	else
		return "((" + type_val + ")(" + expr + "))";
}

string generate_c_cast(Type const &target_type, Expr const &expr, CBackend &backend)
{
	return generate_c_cast(target_type, generate_c(expr, backend), *type_of(expr));
}

string generate_c(Expr const &expr, CBackend &backend, bool need_result)
{
	return expr | match
	{
		[&](IntLiteralExpr const &e)
		{
			return str(e.value);
		},
		[&](BoolLiteralExpr const &e)
		{
			return string(e.value ? "true" : "false");
		},
		[&](StringLiteralExpr const &e)
		{
			switch(e.kind)
			{
				case StringLiteralKind::C:
					// In C, `char` is a type distinct from `signed char` and `unsigned char`.
					// However, in Myca, we define `c_char` to be equal to either `i8` (aka `signed
					// char`) or `u8` (aka `unsigned char`).
					// Thus, we need to insert a cast to keep the C compiler happy.
					return "(" + generate_c_to_str(*e.type) + ")\""s + e.value + '"';
			}

			UNREACHABLE;
		},
		[&](VarExpr const &e)
		{
			return string(e.var->name);
		},
		[&](ConstructorExpr const &e)
		{
			StructType const &st = std::get<StructType>(*e.ctor);
			if(st.inst->struct_()->name == "c_char")
				return "(char)"s;

			return mangle_constructor(StructType(UNKNOWN_TOKEN_RANGE, st.inst));
		},
		[&](ProcExpr const &e)
		{
			return mangle_procedure(e.inst);
		},
		[&](UnaryExpr const &e)
		{
			string sub_val = generate_c(*e.sub, backend);
			switch(e.op)
			{
				case UnaryOp::NOT: return "(!" + sub_val + ")";
				case UnaryOp::NEG: return "(-" + sub_val + ")";
			}

			UNREACHABLE;
		},
		[&](BinaryExpr const &e)
		{
			string left_val = generate_c(*e.left, backend);
			string right_val = generate_c(*e.right, backend);
			switch(e.op)
			{
				case BinaryOp::ADD: return "(" + left_val + " + " + right_val + ")";
				case BinaryOp::SUB: return "(" + left_val + " - " + right_val + ")";
				case BinaryOp::MUL: return "(" + left_val + " * " + right_val + ")";
				case BinaryOp::DIV: return "(" + left_val + " / " + right_val + ")";

				case BinaryOp::EQ: return "(" + left_val + " == " + right_val + ")";
				case BinaryOp::LT: return "(" + left_val + " < "  + right_val + ")";
				case BinaryOp::LE: return "(" + left_val + " <= " + right_val + ")";
				case BinaryOp::GT: return "(" + left_val + " > "  + right_val + ")";
				case BinaryOp::GE: return "(" + left_val + " >= " + right_val + ")";
			}

			UNREACHABLE;
		},
		[&](AddressOfExpr const &e)
		{
			string object_val = generate_c(*e.object, backend);
			return "&(" + object_val + ")";
		},
		[&](DerefExpr const &e)
		{
			string ptr_val = generate_c(*e.addr, backend);
			return "(*(" + ptr_val + "))";
		},
		[&](IndexExpr const &e)
		{
			string ptr_val = generate_c(*e.addr, backend);
			string idx_val = generate_c(*e.index, backend);
			return "(" + ptr_val + ")[" + idx_val + "]";
		},
		[&](MemberAccessExpr const &e)
		{
			if(is_optional_ptr(*type_of(*e.object)) && e.member == "value")
				return generate_c(*e.object, backend);
			else
			{
				string object_val = generate_c(*e.object, backend);
				return object_val + "." + e.member;
			}
		},
		[&](AssignmentExpr const &e)
		{
			string rhs_val = generate_c_cast(*type_of(*e.lhs), *e.rhs, backend);
			string lhs_val = generate_c(*e.lhs, backend);
			return "(" + lhs_val + " = " + rhs_val + ")";
		},
		[&](AsExpr const &e)
		{
			return generate_c_cast(*e.target_type, *e.src_expr, backend);
		},
		[&](CallExpr const &e)
		{
			if(ConstructorExpr const *ctor_expr = std::get_if<ConstructorExpr>(e.callable))
			{
				if(Type const *pointee_type = is_optional_ptr(*ctor_expr->ctor))
				{
					StructType const &ctor_type = std::get<StructType>(*ctor_expr->ctor);
					if(ctor_type.inst->struct_()->name == "None")
						return "NULL"s;

					// Optional.Some
					return generate_c_cast(*pointee_type, e.args->items[0].expr, backend);
				}
			}

			ProcType const &callable_proc_type = std::get<ProcType>(*type_of(*e.callable));
			FixedArray<Type> const *param_types = callable_proc_type.inst->params;

			// Evaluate arguments in the order they were provided
			vector<string> arg_vals(param_types->count);
			for(Argument const &arg: *e.args)
			{
				Type const &param_type = param_types->items[arg.param_idx];
				arg_vals[arg.param_idx] = generate_c_cast(param_type, arg.expr, backend);
			}

			// Evaluate a parameter's default value if an argument is missing
			size_t param_count = callable_proc_type.param_count();
			for(size_t i = 0; i < param_count; ++i)
			{
				if(arg_vals[i].empty())
				{
					assert(callable_proc_type.param_default_value_at(i));
					Expr const &default_value = callable_proc_type.param_default_value_at(i).get_expr();
					arg_vals[i] = generate_c_cast(param_types->items[i], default_value, backend);
				}
			}

			// Create a variable to store the procedure's return value
			Type const &ret_type = *e.type;
			string result_var;
			if(!equiv(ret_type, BuiltinType(UNKNOWN_TOKEN_RANGE, BuiltinTypeDef::UNIT)) && need_result)
			{
				result_var = backend.new_tmp_var();
				backend << ret_type << " " << result_var << " = ";
			}

			// Make the call
			string callable_val = generate_c(*e.callable, backend);
			backend << callable_val << "(";
			backend << RangeFmt(arg_vals, ", ", [&](auto &arg_val) { backend << arg_val; });
			backend << ");" << LineEnd;

			return result_var;
		},
		[&](SizeOfExpr const &e)
		{
			return "sizeof(" + generate_c_to_str(*e.subject) + ")";
		},
		[&](MakeExpr const &e)
		{
			string addr_val = generate_c(*e.addr, backend);

			string result_var = backend.new_tmp_var();
			backend << *e.type << " " << result_var << " = " << generate_c_cast(*e.type, addr_val, *type_of(*e.addr)) << ";" << LineEnd;

			string init_val = generate_c(*e.init, backend);
			backend << "*" << result_var << " = " << init_val << ";" << LineEnd;

			return result_var;
		},
		[&](Path const&) -> string { assert(!"generate_c: Path"); },
	};
}


//==============================================================================
// Statements
//==============================================================================
void generate_c_pattern(Pattern const &lhs_pattern, string const &rhs_expr, Type const &rhs_type, CBackend &backend)
{
	lhs_pattern | match
	{
		[&](VarPattern const &p)
		{
			string expr_str = generate_c_cast(*p.type, rhs_expr, rhs_type);
			backend << *p.type << " " << p.var->name << " = " << expr_str << ";" << LineEnd;
		},
		[&](DerefPattern const &p)
		{
			string deref_expr = generate_c_cast(*std::get<PointerType>(rhs_type).pointee, "*(" + rhs_expr + ")", *p.type);
			generate_c_pattern(*p.sub, deref_expr, *p.type, backend);
		},
		[&](AddressOfPattern const &p)
		{
			string addr_expr = generate_c_cast(
				PointerType(UNKNOWN_TOKEN_RANGE, &const_cast<Type&>(rhs_type), p.mutability),
				"&(" + rhs_expr + ")",
				*p.type
			);
			generate_c_pattern(*p.sub, addr_expr, *p.type, backend);
		},
		[&](ConstructorPattern const &p)
		{
			StructType const *ctor = std::get_if<StructType>(p.ctor);
			if(p.has_parens and ctor and ctor->inst->try_get_ctor_type())
			{
				ProcType &ctor_type = std::get<ProcType>(*ctor->inst->try_get_ctor_type());
				assert(p.args->count == ctor_type.inst->params->count);
				for(PatternArgument const &arg: *p.args)
				{
					string object_str = generate_c_cast(*p.ctor, rhs_expr, rhs_type);
					Type const &param_type = ctor_type.inst->params->items[arg.param_idx];

					if(is_optional_ptr(*p.ctor) && ctor_type.param_name_at(arg.param_idx) == "value")
						generate_c_pattern(arg.pattern, object_str, param_type, backend);
					else
						generate_c_pattern(arg.pattern, object_str + "." + ctor_type.param_name_at(arg.param_idx), param_type, backend);
				}
			}
		},
		[&](WildcardPattern const&) {},
		[&](VarPatternUnresolved const&) { assert(!"generate_c_pattern: VarPatternUnresolved"); },
	};
}

MatchArm const* get_optional_some(MatchStmt const &stmt)
{
	for(MatchArm const &arm: *stmt.arms)
	{
		if(StructType const *st = std::get_if<StructType>(&type_of(arm.capture)))
		{
			if(st->inst->struct_()->name == "Option" or st->inst->struct_()->name == "Some")
				return &arm;
		}
	}

	return nullptr;
}

MatchArm const* get_optional_none(MatchStmt const &stmt)
{
	for(MatchArm const &arm: *stmt.arms)
	{
		if(StructType const *st = std::get_if<StructType>(&type_of(arm.capture)))
		{
			if(st->inst->struct_()->name == "Option" or st->inst->struct_()->name == "None")
				return &arm;
		}
	}

	return nullptr;
}

void generate_c(Stmt const &stmt, CBackend &backend)
{
	stmt | match
	{
		[&](LetStmt const &s)
		{
			if(s.init_expr)
			{
				string init_expr_var = generate_c(*s.init_expr, backend);
				generate_c_pattern(*s.lhs, init_expr_var, *type_of(*s.init_expr), backend);
			}
			else
			{
				Var *var = std::get<VarPattern>(*s.lhs).var;
				backend << *var->type << " " << var->name << ";" << LineEnd;
			}
		},
		[&](ExprStmt const &s)
		{
			string expr_str = generate_c(*s.expr, backend, false);
			if(expr_str.length())
				backend << expr_str << ";" << LineEnd;
		},
		[&](BlockStmt const &s)
		{
			backend << "{" << LineEnd;
			backend.increase_indent();

			for(Stmt const &stmt: *s.stmts)
				generate_c(stmt, backend);

			backend.decrease_indent();
			backend << "}" << LineEnd;
		},
		[&](ReturnStmt const &s)
		{
			if(s.ret_expr)
			{
				Type const *ret_type = backend.proc()->get_proc_type().inst->ret;
				string ret_val = generate_c_cast(*ret_type, *s.ret_expr, backend);
				backend << "return " << ret_val << ";" << LineEnd;
			}
			else
				backend << "return;" << LineEnd;
		},
		[&](IfStmt const &s)
		{
			string cond_str = generate_c(*s.condition, backend);
			backend << "if(" << cond_str << ")" << LineEnd;
			generate_c(*s.then, backend);
			if(s.else_)
			{
				backend << "else" << LineEnd;
				generate_c(*s.else_, backend);
				backend << LineEnd;
			}
		},
		[&](WhileStmt const &s)
		{
			backend << "while(true)" << LineEnd;
			backend << "{" << LineEnd;
			backend.increase_indent();
				string cond_str = generate_c(*s.condition, backend);
				backend << "if(!" << cond_str << ") break;" << LineEnd;
				generate_c(*s.body, backend);
			backend.decrease_indent();
			backend << "}" << LineEnd;
		},
		[&](MatchStmt const &s)
		{
			if(is_optional_ptr(*type_of(*s.expr)))
			{
				string subject_str = generate_c(*s.expr, backend);
				backend << "if(" << subject_str << ")" << LineEnd;
				backend << "{" << LineEnd;
				backend.increase_indent();
					if(MatchArm const *some_arm = get_optional_some(s))
					{
						generate_c_pattern(some_arm->capture, subject_str, *type_of(*s.expr), backend);
						generate_c(some_arm->stmt, backend);
					}
				backend.decrease_indent();
				backend << "}" << LineEnd;
				backend << "else" << LineEnd;
				backend << "{" << LineEnd;
				backend.increase_indent();
					if(MatchArm const *none_arm = get_optional_none(s))
					{
						generate_c_pattern(none_arm->capture, subject_str, *type_of(*s.expr), backend);
						generate_c(none_arm->stmt, backend);
					}
				backend.decrease_indent();
				backend << "}" << LineEnd;
			}
			else
			{
				string subject_str = generate_c(*s.expr, backend);
				backend << "switch(" << subject_str << ".__myca__discr)" << LineEnd;
				backend << "{" << LineEnd;
				backend.increase_indent();
					bool has_wildcard = false;
					for(MatchArm const &arm: *s.arms)
					{
						if(is<WildcardPattern>(arm.capture))
						{
							backend << "default:" << LineEnd;
							has_wildcard = true;
						}
						else
							backend << "case " << arm.discr << ":" << LineEnd;

						backend << "{" << LineEnd;
						backend.increase_indent();

						if(not is<WildcardPattern>(arm.capture))
						{
							if(is<UnionType>(*type_of(*s.expr)))
							{
								string arm_expr = subject_str + ".__myca_alt" + std::to_string(arm.discr);
								generate_c_pattern(arm.capture, arm_expr, type_of(arm.capture), backend);
							}
							else
								generate_c_pattern(arm.capture, subject_str, *type_of(*s.expr), backend);
						}

						generate_c(arm.stmt, backend);

						backend.decrease_indent();
						backend << "}" << LineEnd;

						backend << "break;" << LineEnd;
					}
					if(not has_wildcard)
						backend << "default: assert(0);" << LineEnd;
				backend.decrease_indent();
				backend << "}" << LineEnd;
			}
		},
	};
}


//==============================================================================
// Structs
//==============================================================================

// Generate C struct fields for all the variable members of `struct_` that come before the first
// case member
void create_c_struct_initial_vars(StructInstance *struct_inst, optional<size_t> child_case_idx, CStruct *result)
{
	if(struct_inst->parent())
		create_c_struct_initial_vars(struct_inst->parent(), struct_inst->case_idx(), result);

	if(struct_inst->struct_()->num_case_members)
		// TODO When the struct contains multiple nested case members then the name is not
		// unique anymore
		result->add(CMember("__myca__discr", child_case_idx, *struct_inst->discriminator_type()));

	for(Parameter const &member: struct_inst->initial_var_members())
	{
		string member_name = string(name_of(member, &struct_inst->mod()));
		result->add(CMember(member_name, *member.type));
	}
}

// Generate C struct fields for all the variable members of `struct_inst` that come after its case members
void create_c_struct_trailing_vars(StructInstance *struct_inst, CStruct *result)
{
	for(Parameter const &member: struct_inst->trailing_var_members())
	{
		string member_name = string(name_of(member, &struct_inst->mod()));
		result->add(CMember(member_name, *member.type));
	}

	if(struct_inst->parent())
	{
		size_t additional_padding = struct_inst->parent()->cases_layout().end() - result->cur_layout.size;
		if(additional_padding)
		{
			for(size_t i = 0; i < additional_padding; ++i)
				result->add(CMember(BuiltinType(UNKNOWN_TOKEN_RANGE, BuiltinTypeDef::U8)));
		}

		create_c_struct_trailing_vars(struct_inst->parent(), result);
	}
}

CStruct create_c_struct(StructInstance *struct_inst)
{
	CStruct result{
		mangle_type(StructType(UNKNOWN_TOKEN_RANGE, struct_inst)),
		mangle_constructor(StructType(UNKNOWN_TOKEN_RANGE, struct_inst))
	};

	create_c_struct_initial_vars(struct_inst, nullopt, &result);

	if(struct_inst->struct_()->num_case_members)
	{
		for(size_t i = 0; i < struct_inst->cases_layout().size; ++i)
			result.add(CMember(BuiltinType(UNKNOWN_TOKEN_RANGE, BuiltinTypeDef::U8)));
	}

	create_c_struct_trailing_vars(struct_inst, &result);

	MemoryLayout struct_layout = struct_inst->layout();
	assert(result.cur_layout.size == struct_layout.size);
	result.cur_layout.alignment = std::max(result.cur_layout.alignment, struct_layout.alignment);

	return result;
}

void generate_c_struct_methods(CStruct const &cstruct, CBackend &backend)
{
	// Generate constructor
	{
		// Function header
		backend << "struct " << cstruct.name << " " << cstruct.constructor_name << "(";
		bool first = true;
		for(CMember const &member: cstruct.members)
		{
			member.kind | match
			{
				[&](CMemberNormal const &m)
				{
					if(first) first = false;
					else backend << ", ";

					backend << member.type << " " << m.name;
				},
				[&](CMemberConst const&) {},
				[&](CMemberPadding) {},
			};
		}
		backend << ")" << LineEnd;
		
		// Function body
		backend << "{" << LineEnd;
		backend.increase_indent();
			backend << "struct " << cstruct.name << " __myca__object = {";
			backend.increase_indent();
				backend << RangeFmt(cstruct.members, ", ", [&](CMember const &member)
				{
					member.kind | match
					{
						[&](CMemberNormal const &m) { backend << m.name; },
						[&](CMemberConst const &m) { backend << m.value; },
						[&](CMemberPadding) { backend << "0"; },
					};
				});
			backend.decrease_indent();
			backend << "};" << LineEnd;
			backend << "return __myca__object;" << LineEnd;
		backend.decrease_indent();
		backend << "}" << LineEnd;
	}
}


//==============================================================================
// Procedures
//==============================================================================
void generate_c_proc_sig(ProcInstance *proc, CBackend &backend)
{
	ProcTypeInstance const *proc_type = proc->get_proc_type().inst;
	Type const *ret_type = proc_type->ret;
	if(is_builtin_type(*ret_type, BuiltinTypeDef::UNIT))
		backend << "void";
	else
		backend << *ret_type;

	backend << " " << mangle_procedure(proc) << "(";
	for(size_t i = 0; i < proc_type->params->count; ++i)
	{
		if(i != 0) backend << ", ";

		string_view param_name = proc->get_proc_type().param_name_at(i);
		backend << proc_type->params->items[i] << " " << param_name;
	}
	backend << ")";
}


//==============================================================================
// Whole module
//==============================================================================
void _sort_types_by_deps(
	TypeInstance type,
	vector<TypeInstance> &result,
	unordered_set<TypeInstance> &visited,
	Module &mod
)
{
	// We assume the semantic analysis would already have detected any dependency cycles
	auto res = visited.insert(type);
	if(!res.second)
		return;

	type | match
	{
		[&](StructInstance const *inst)
		{
			while(inst)
			{
				for(TypeInstance dep: inst->own_type_deps())
					_sort_types_by_deps(dep, result, visited, mod);

				inst = inst->parent();
			}
		},
		[&](UnionInstance const*)
		{
			assert(!"[TODO] _sort_types_by_deps: UnionInstance");
		},
	};

	result.push_back(type);
}

vector<TypeInstance> sort_types_by_deps(vector<TypeInstance> const &types, Module &mod)
{
	vector<TypeInstance> result;
	unordered_set<TypeInstance> visited;
	for(TypeInstance type: types)
		_sort_types_by_deps(type, result, visited, mod);

	return result;
}

/*void gather_concrete_instances(StructDef *struct_, vector<TypeInstance> &result)
{
	for(auto &[_, inst]: struct_->instances)
	{
		if(inst.is_concrete())
			result.push_back(&inst);
	}

	for(Member &member: struct_->members)
	{
		if(StructDef **case_member = std::get_if<StructDef*>(&member))
			gather_concrete_instances(*case_member, result);
	}
}*/

struct ConcreteProcInstance
{
	explicit ConcreteProcInstance(ProcInstance *proc) :
		proc(proc)
	{
		assert(proc->is_concrete());
		if(proc->proc()->body)
		{
			body = clone(*proc->proc()->body, proc->registry()->arena());
			substitute_types_in_stmt(*body, proc->create_type_env(), *proc->registry());
		}
	}

	ProcInstance *proc;
	optional<Stmt> body;
};

void generate_c(Module &mod, CBackend &backend)
{
	for(TopLevelItem &item: to_range(mod.items))
	{
		item | match
		{
			[&](ProcItem &proc)
			{
				// ProcInstances are only created for procedures that are actually referenced in the
				// code. But we want to generate code for all procedures (especially for main()), so
				// we explicitly create ProcInstances if they are missing.
				if(proc.body and proc.type_params->count == 0)
					mod.sema->insts.get_proc_instance(&proc, nullptr);
			},
			[&](StructItem&) {},
			[&](AliasItem&) {},
		};
	}

	// Gather all StructInstances and ProcInstances
	vector<TypeInstance> types;
	vector<ConcreteProcInstance> procs;
	for_each_instance(mod.sema->insts, match
	{
		[&](StructInstance *struct_)
		{
			if(struct_->is_concrete())
				types.push_back(struct_);
		},
		[&](ProcInstance *proc)
		{
			if(proc->is_concrete())
				procs.push_back(ConcreteProcInstance(proc));
		},
	});

	// Generate type definitions
	vector<TypeInstance> sorted_types = sort_types_by_deps(types, mod);
	unordered_map<StructInstance*, CStruct> cstructs;
	for(TypeInstance type: sorted_types)
	{
		type | match
		{
			[&](StructInstance *inst)
			{
				CStruct cstruct = create_c_struct(inst);
				generate_c_struct_def(cstruct, backend);
				backend << LineEnd;

				cstructs.emplace(inst, std::move(cstruct));
			},
			[&](UnionInstance const*)
			{
				//generate_c_union_type(*union_, backend);
			},
		};
	}

	// Generate internal functions that are associated with a type (at the moment, this only
	// consists of constructors for structs)
	for(TypeInstance type: sorted_types)
	{
		type | match
		{
			[&](StructInstance *inst)
			{
				generate_c_struct_methods(cstructs.at(inst), backend);
				backend << LineEnd;
			},
			[&](UnionInstance const*) {},
		};
	}

	// Generate forward declarations for all functions
	for(ConcreteProcInstance &inst: procs)
	{
		generate_c_proc_sig(inst.proc, backend);
		backend << ";" << LineEnd;
	}

	// Generate function bodies
	for(ConcreteProcInstance &inst: procs)
	{
		if(inst.body)
		{
			backend.set_current_proc(inst.proc);
			generate_c_proc_sig(inst.proc, backend);
			backend << LineEnd;
			generate_c(*inst.body, backend);
			backend << LineEnd;
		}
	}
}
